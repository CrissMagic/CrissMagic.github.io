<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>RocketMQ学习（一）-----概览 | 一人行者</title><script src="https://cdn.bootcss.com/valine/1.4.4/Valine.min.js"></script><link rel="stylesheet" href="/css/arknights.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark-reasonable.min.css"><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="一人行者" type="application/atom+xml">
</head><body><header><nav><a href="/">Home</a><a href="/archives/">Archives</a></nav></header><main><article><div id="post-bg"><div id="post-title"><h1>RocketMQ学习（一）-----概览</h1><hr></div><div id="post-content"><p><img src="https://img.hacpai.com/bing/20180107.jpg?imageView2/1/w/960/h/540/interlace/1/q/100"> </p>
<h2 id="RocketMQ概览"><a href="#RocketMQ概览" class="headerlink" title="RocketMQ概览"></a>RocketMQ概览</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2838890f3284">参考网址1</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5c8089b43556">参考网址2</a></p>
</blockquote>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><p>RocketMQ有以下主要特点：</p>
<ul>
<li>灵活可扩展性<br>  RocketMQ 天然支持集群，其核心四组件（Name Server、Broker、Producer、Consumer）每一个都可以在没有单点故障的情况下进行水平扩展。</li>
<li>海量消息堆积能力<br>  RocketMQ 采用零拷贝原理实现超大的消息的堆积能力，据说单机已可以支持亿级消息堆积，而且在堆积了这么多消息后依然保持写入低延迟。</li>
<li>支持顺序消息<br>  可以保证消息消费者按照消息发送的顺序对消息进行消费。顺序消息分为全局有序和局部有序，一般推荐使用局部有序，即生产者通过将某一类消息按顺序发送至同一个队列来实现。</li>
<li>多种消息过滤方式<br>  消息过滤分为在服务器端过滤和在消费端过滤。服务器端过滤时可以按照消息消费者的要求做过滤，优点是减少不必要消息传输，缺点是增加了消息服务器的负担，实现相对复杂。消费端过滤则完全由具体应用自定义实现，这种方式更加灵活，缺点是很多无用的消息会传输给消息消费者。</li>
<li>支持事务消息<br>  RocketMQ 除了支持普通消息，顺序消息之外还支持事务消息，这个特性对于分布式事务来说提供了又一种解决思路。</li>
<li>回溯消费<br>  回溯消费是指消费者已经消费成功的消息，由于业务上需求需要重新消费，RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯。</li>
</ul>
<h3 id="优势与比较"><a href="#优势与比较" class="headerlink" title="优势与比较"></a>优势与比较</h3><p>消息队列是高并发系统的核心组件之一，能帮助业务系统解构提升开发效率和系统稳定性</p>
<p>有以下优势：</p>
<ul>
<li>削峰填谷（主要解决瞬时写压力大于应用服务能力导致消息丢失、系统奔溃等问题）</li>
<li>系统解耦（解决不同重要程度、不同能力级别系统之间依赖导致一死全死）</li>
<li>提升性能（当存在一对多调用时，可以发一条消息给消息系统，让消息系统通知相关系统）</li>
<li>蓄流压测（线上有些链路不好压测，可以通过堆积一定量消息再放开来压测）</li>
</ul>
<p>相对而言RocketMQ的优势：</p>
<ul>
<li>支持事务型消息（消息发送和DB操作保持两方的最终一致性，RabbitMQ和Kafka不支持）</li>
<li>支持结合RabbitMQ的多个系统之间数据最终一致性（多方事务，二方事务是前提）</li>
<li>支持18个级别的延迟消息（RabbitMQ和Kafka不支持）</li>
<li>支持指定次数和时间间隔的失败消息重发（Kafka不支持，RabbitMQ需要手动确认）</li>
<li>支持consumer端tag过滤，减少不必要的网络传输（RabbitMQ和Kafka不支持）</li>
<li>支持重复消费（RabbitMQ不支持，Kafka支持）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://upload-images.jianshu.io/upload_images/12619159-ebd12b24d5ae33d9.png">Kafka、RocketMQ、RabbitMQ对比图</a></p>
<h4 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h4><p>为提高消息读写并发能力，将一个topic消息进行拆分，kafka称为分区，rocketmq称为队列。</p>
<ul>
<li>对于kafka：为了防止一个分区的消息文件过大，会拆分成一个个固定大小的文件，所以一个分区就对应了一个目录。分区与分区之间是相互隔离的。</li>
<li>对于RocketMQ：则是所有topic的数据混在一起进行存储，默认超过1G的话，则重新创建一个新的文件。消息的写入过程即写入该混杂的文件中，然后又有一个线程服务，在不断的读取分析该混杂文件，将消息进行分拣，然后存储在对应队列目录中（存储的是简要信息，如消息在混杂文件中的offset，消息大小等）</li>
<li>所以RocketMQ需要2次寻找，第一次先找队列中的消息概要信息，拿到概要信息中的offset，根据这个offset再到混杂文件中找到想要的消息。而kafka则只需要直接读取分区中的文件即可得到想要的消息</li>
</ul>
<h4 id="producer端发现"><a href="#producer端发现" class="headerlink" title="producer端发现"></a>producer端发现</h4><p>Producer端如何来发现新的broker地址。</p>
<ul>
<li>对于kafka来说：Producer端需要配置broker的列表地址，Producer也从一个broker中来更新broker列表地址（从中发现新加入的broker）。</li>
<li>对于RocketMQ来说：Producer端需要Name Server的列表地址，同时还可以定时从一个HTTP地址中来获取最新的Name Server的列表地址，然后从其中的一台Name Server来获取全部的路由信息，从中发现新的broker。</li>
</ul>
<h4 id="消费offset的存储"><a href="#消费offset的存储" class="headerlink" title="消费offset的存储"></a>消费offset的存储</h4><ul>
<li>对于kafka：Consumer将消费的offset定时存储到ZooKeeper上，利用ZooKeeper保障了offset的高可用问题。</li>
<li>对于RocketMQ:Consumer将消费的offset定时存储到broker所在的机器上，这个broker优先是master，如果master挂了的话，则会选择slave来存储，broker也是将这些offset定时刷新到本地磁盘上，同时slave会定时的访问master来获取这些offset。</li>
</ul>
<h4 id="consumer负载均衡"><a href="#consumer负载均衡" class="headerlink" title="consumer负载均衡"></a>consumer负载均衡</h4><ul>
<li>对于负载均衡，在出现分区或者队列增加或者减少的时候、Consumer增加或者减少的时候都会进行reblance操作。</li>
<li>对于RocketMQ:客户端自己会定时对所有的topic的进行reblance操作，对于每个topic，会从broker获取所有Consumer列表，从broker获取队列列表，按照负载均衡策略，计算各自负责哪些队列。这种就要求进行负载均衡的时候，各个Consumer获取的数据是一致的，不然不同的Consumer的reblance结果就不同。</li>
<li>对于kafka：kafka之前也是客户端自己进行reblance，依靠ZooKeeper的监听，来监听上述2种情况的出现，一旦出现则进行reblance。现在的版本则将这个reblance操作转移到了broker端来做，不但解决了RocketMQ上述的问题，同时减轻了客户端的操作，使得客户端更加轻量级，减少了和其他语言集成的工作量。</li>
</ul>
<h3 id="集群结构"><a href="#集群结构" class="headerlink" title="集群结构"></a>集群结构</h3><h4 id="1、Name-Server"><a href="#1、Name-Server" class="headerlink" title="1、Name Server"></a>1、Name Server</h4><p>Name Server是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p>
<h4 id="2、Broker"><a href="#2、Broker" class="headerlink" title="2、Broker"></a>2、Broker</h4><p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的Broker Name，不同的Broker Id来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。</p>
<p>每个Broker与Name Server集群中的所有节点建立长连接，定时(每隔30s)注册Topic信息到所有Name Server。Name Server定时(每隔10s)扫描所有存活broker的连接，如果Name Server超过2分钟没有收到心跳，则Name Server断开与Broker的连接。</p>
<h4 id="3、Producer"><a href="#3、Producer" class="headerlink" title="3、Producer"></a>3、Producer</h4><p>Producer与Name Server集群中的其中一个节点(随机选择)建立长连接，定期从Name Server取Topic路由信息（有点像zookeeper作注册中心），并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</p>
<p>Producer每隔30s（由ClientConfig的pollNameServerInterval）从Name server获取所有topic队列的最新情况，这意味着如果Broker不可用，Producer最多30s能够感知，在此期间内发往Broker的所有消息都会失败。</p>
<p>Producer每隔30s（由ClientConfig中heartbeatBrokerInterval决定）向所有关联的broker发送心跳，Broker每隔10s中扫描所有存活的连接，如果Broker在2分钟内没有收到心跳数据，则关闭与Producer的连接。</p>
<p>生产者（Producer）负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。 RocketMQ 提供了三种方式发送消息：同步、异步和单向。</p>
<h5 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h5><p>同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。</p>
<h5 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h5><p>异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。</p>
<h5 id="单向发送"><a href="#单向发送" class="headerlink" title="单向发送"></a>单向发送</h5><p>单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。</p>
<h5 id="生产者组"><a href="#生产者组" class="headerlink" title="生产者组"></a>生产者组</h5><p>生产者组（Producer Group）是一类 Producer 的集合，这类 Producer 通常发送一类消息并且发送逻辑一致，所以将这些 Producer 分组在一起。从部署结构上看生产者通过 Producer Group 的名字来标记自己是一个集群。</p>
<h4 id="4、Consumer"><a href="#4、Consumer" class="headerlink" title="4、Consumer"></a>4、Consumer</h4><p>Consumer与Name Server集群中的其中一个节点(随机选择)建立长连接，定期从Name Server取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。</p>
<p>Consumer每隔30s从Name server获取topic的最新队列情况，这意味着Broker不可用时，Consumer最多最需要30s才能感知。</p>
<p>Consumer每隔30s（由ClientConfig中heartbeatBrokerInterval决定）向所有关联的broker发送心跳，Broker每隔10s扫描所有存活的连接，若某个连接2分钟内没有发送心跳数据，则关闭连接；并向该Consumer Group的所有Consumer发出通知，Group内的Consumer重新分配队列，然后继续消费。</p>
<p>当Consumer得到master宕机通知后，转向slave消费，slave不能保证master的消息100%都同步过来了，因此会有少量的消息丢失。但是一旦master恢复，未同步过去的消息会被最终消费掉。</p>
<p>消费者对列是消费者连接之后（或者之前有连接过）才创建的。我们将原生的消费者标识由 {IP}@{消费者group}扩展为 {IP}@{消费者group}{topic}{tag}，（例如xxx.xxx.xxx.xxx@mqtest_producer-group_2m2sTest_tag-zyk）。任何一个元素不同，都认为是不同的消费端，每个消费端会拥有一份自己消费对列（默认是broker对列数量*broker数量）。新挂载的消费者对列中拥有commitlog中的所有数据。</p>
<h3 id="分布式事务消息"><a href="#分布式事务消息" class="headerlink" title="分布式事务消息"></a>分布式事务消息</h3><h4 id="两方事务"><a href="#两方事务" class="headerlink" title="两方事务"></a>两方事务</h4><blockquote>
<p>原理：大事务 = 小事务 + 异步 从而达到最终一致性</p>
</blockquote>
<p>具体过程为：</p>
<ol>
<li>发送消息到MQ服务器，此时消息状态为SEND_OK。此消息为consumer不可见。</li>
<li>执行DB操作；DB执行成功Commit DB操作，DB执行失败Rollback DB操作。</li>
<li>如果DB执行成功，回复MQ服务器，将状态为COMMIT_MESSAGE；如果DB执行失败，回复MQ服务器，将状态改为ROLLBACK_MESSAGE。注意此过程有可能失败。</li>
<li>MQ内部提供一个名为“事务状态服务”的服务，此服务会检查事务消息的状态，如果发现消息未COMMIT，则通过Producer启动时注册的TransactionCheckListener来回调业务系统，业务系统在checkLocalTransactionState方法中检查DB事务状态，如果成功，则回复COMMIT_MESSAGE，否则回复ROLLBACK_MESSAGE。</li>
</ol>
<p>注意：</p>
<blockquote>
<p>1、以上SEND_OK、COMMIT_MESSAGE、ROLLBACK_MESSAGE均是client jar提供的状态，在MQ服务器内部是一个数字<br>2、TransactionCheckListener 是在消息的commit或者rollback消息丢失的情况下才会回调。这种消息丢失只存在于断网或者rocketmq集群挂了的情况下。当rocketmq集群挂了，如果采用异步刷盘，存在1s内数据丢失风险，异步刷盘场景下保障事务没有意义。所以如果要核心业务用Rocketmq解决分布式事务问题，建议选择同步刷盘模式。</p>
</blockquote>
<h4 id="多方事务"><a href="#多方事务" class="headerlink" title="多方事务"></a>多方事务</h4><blockquote>
<p>原理：引入TCC模式思想（Try-Confirm-Cancel）</p>
</blockquote>
<p>以交易系统为例：</p>
<ol>
<li>交易系统创建订单（往DB插入一条记录），同时发送订单创建消息。通过RocketMq事务性消息保证一致性</li>
<li>接着执行完成订单所需的同步核心RPC服务（非核心的系统通过监听MQ消息自行处理，处理结果不会影响交易状态）。执行成功更改订单状态，同时发送MQ消息。</li>
<li>交易系统接受自己发送的订单创建消息，通过定时调度系统创建延时回滚任务（或者使用RocketMq的重试功能，设置第二次发送时间为定时任务的延迟创建时间。在非消息堵塞的情况下，消息第一次到达延迟为1ms左右，这时可能RPC还未执行完，订单状态还未设置为完成，第二次消费时间可以指定）。延迟任务先通过查询订单状态判断订单是否完成，完成则不创建回滚任务，否则创建。</li>
<li>注意：多个RPC可以创建一个回滚任务，通过一个消费组接受一次消息就可以；也可以通过创建多个消费组，一个消息消费多次，每次消费创建一个RPC的回滚任务。 回滚任务失败，通过MQ的重发来重试。</li>
</ol>
<h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><h4 id="顺序消息的缺陷"><a href="#顺序消息的缺陷" class="headerlink" title="顺序消息的缺陷"></a>顺序消息的缺陷</h4><p>发送顺序消息无法利用集群Fail Over特性消费顺序消息的并行度依赖于队列数量队列热点问题，个别队列由于哈希不均导致消息过多，消费速度跟不上，产生消息堆积问题遇到消息失败的消息，无法跳过，当前队列消费暂停。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>produce在发送消息的时候，把消息发到同一个队列（queue）中,消费者注册消息监听器为MessageListenerOrderly，这样就可以保证消费端只有一个线程去消费消息。</p>
<p>注意：把消息发到同一个队列（queue），不是同一个topic，默认情况下一个topic包括4个queue</p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>可以通过实现发送消息的对列选择器方法，实现部分顺序消息。</p>
<p>举例：比如一个数据库通过MQ来同步，只需要保证每个表的数据是同步的就可以。解析binlog，将表名作为对列选择器的参数，这样就可以保证每个表的数据到同一个对列里面，从而保证表数据的顺序消费</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h4 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h4><ol>
<li>Topic<ul>
<li>一个应用尽可能用一个Topic，消息子类型用tags来标识，tags可以由应用自由设置。只有发送消息设置了tags，消费方在订阅消息时，才可以利用tags 在broker做消息过滤。</li>
</ul>
</li>
<li>key<ul>
<li>每个消息在业务层面的唯一标识码，要设置到 keys 字段，方便将来定位消息丢失问题。服务器会为每个消息创建索引(哈希索引)，应用可以通过 topic，key来查询这条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证key 尽可能唯一，这样可以避免潜在的哈希冲突。</li>
</ul>
</li>
</ol>
<blockquote>
<p>例如：订单Id  String orderId= “20034568923546”;  message.setKeys(orderId);</p>
</blockquote>
<ol start="3">
<li>日志<ul>
<li>消息发送成功或者失败，要打印消息日志，务必要打印 send result 和key 字段。</li>
</ul>
</li>
<li>send<ul>
<li>send消息方法，只要不抛异常，就代表发送成功。但是发送成功会有多个状态，在sendResult里定义。</li>
</ul>
</li>
</ol>
<blockquote>
<p>SEND_OK：消息发送成功</p>
<p>FLUSH_DISK_TIMEOUT：消息发送成功，但是服务器刷盘超时，消息已经进入服务器队列，只有此时服务器宕机，消息才会丢失</p>
<p>FLUSH_SLAVE_TIMEOUT：消息发送成功，但是服务器同步到Slave时超时，消息已经进入服务器队列，只有此时服务器宕机，消息才会丢失</p>
<p>SLAVE_NOT_AVAILABLE：消息发送成功，但是此时slave不可用，消息已经进入服务器队列，只有此时服务器宕机，消息才会丢失</p>
</blockquote>
<h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><ol>
<li>幂等<ul>
<li>RocketMQ使用的消息原语是At Least Once，所以consumer可能多次收到同一个消息，此时务必做好幂等。</li>
</ul>
</li>
<li>日志<ul>
<li>消费时记录日志，以便后续定位问题。</li>
</ul>
</li>
<li>批量消费<ul>
<li>尽量使用批量方式消费方式，可以很大程度上提高消费吞吐量。</li>
</ul>
</li>
</ol>
<div id="paginator"></div></div><div id="post-footer"><hr><a href="/articles/2019/10/11/1570759641494.html">← Prev Linux常用操作整理</a><span style="color: #fe2"> | </span><a href="/hello-solo">Hello,world！ Next →</a><hr></div><div id="bottom-btn"><a id="to-index" href="#post-index" title="index">≡</a><a id="to-top" href="#post-title" title="to top">∧</a></div><div id="Valine"></div><script>new Valine({
 el: '#Valine'
 , appId: ''
 , appKey: ''
 , placeholder: '此条评论委托企鹅物流发送'
})</script></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/"> Dr.CrissMagic</a></h1><section id="total"><a id="total-archives" href="/archives"><span class="total-title">Archives Total:</span><span class="total-number">25</span></a><div id="total-tags"><span class="total-title">Tags:</span><span class="total-number">28</span></div><div id="total-categories"><span class="total-title">Categories:</span><span class="total-number">0</span></div></section></div><div id="aside-block"></div><footer><nobr><span class="text-title">©</span><span class="text-content">1970 to 2020</span></nobr><wbr><nobr><span class="text-title">ICP</span><span class="text-content">——备案号——</span></nobr><wbr><wbr><nobr>published with&nbsp;<a target="_blank" rel="noopener" href="http://hexo.io">Hexo&nbsp;</a></nobr><wbr><nobr>Theme&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknight&nbsp;</a></nobr><wbr><nobr>by&nbsp;<a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/arknights.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script></body></html>